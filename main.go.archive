package main

import (
	"arbitrage/order"
	"arbitrage/transfer"
	"arbitrage/utils"
	"context"
	"fmt"
	"log"
	"math"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"sync"
	"time"
)

type TickerGeneral struct {
	InstId string `json:"instId"`
	Price  string `json:"price"`
	Market string `json:"Market"`
}

type PriceInfo struct {
	Price  float64
	Market string
}

const CAPITAL = 600000.0

func main() {
	tickers := make(chan TickerGeneral)
	orders := make(chan order.Order)

	ctx, cancel := context.WithCancel(context.Background())
	wg := &sync.WaitGroup{}
    
	db, err := utils.Database("orderdb")
    if err != nil {
        log.Fatal("Failed to open LevelDB:", err)
    }
    defer db.Close()

	wg.Add(1)
	go func() {
		defer wg.Done()
		go Kucoin(ctx, tickers)
	}()

	wg.Add(1)
	go func () {
		defer wg.Done()
		binance(ctx, tickers)
	}()

	// Handle interrupt signals for graceful shutdown
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)
	go func() {
		<-c
		log.Println("interrupt signal received")
		cancel()
	}()

	// Store latest prices from each exchange
	prices := make(map[string]map[string]PriceInfo) // InstId -> Market -> PriceInfo
	var mu sync.Mutex

	// Process tickers
	go func() {
		for ticker := range tickers {
			price, err := strconv.ParseFloat(ticker.Price, 64)
			if err != nil {
				log.Printf("invalid price %s for %s: %v", ticker.Price, ticker.InstId, err)
				continue
			}

			mu.Lock()
			if _, exists := prices[ticker.InstId]; !exists {
				prices[ticker.InstId] = make(map[string]PriceInfo)
			}
			prices[ticker.InstId][ticker.Market] = PriceInfo{Price: price, Market: ticker.Market}

			// Check for arbitrage opportunities
			if len(prices[ticker.InstId]) > 1 {
				checkArbitrage(ticker.InstId, prices[ticker.InstId])
			}
			mu.Unlock()
		}
	}()

	go func (){
		for order := range orders {
			fmt.Println(order)
		}
	}()

	// Wait for the WebSocket goroutines to finish
	wg.Wait()
	log.Println("shutting down")
}

func checkArbitrage(instId string, priceInfos map[string]PriceInfo) {
	var minPrice, maxPrice PriceInfo
	first := true
	for _, priceInfo := range priceInfos {
		if first {
			minPrice = priceInfo
			maxPrice = priceInfo
			first = false
		} else {
			if priceInfo.Price < minPrice.Price {
				minPrice = priceInfo
			}
			if priceInfo.Price > maxPrice.Price {
				maxPrice = priceInfo
			}
		}
	}

	if minPrice.Market != maxPrice.Market {
        fees := 0.001 // Assume 0.1% fees for each trade
		coeficient := CAPITAL / (minPrice.Price + (fees * minPrice.Price))
		sellValue := coeficient * (maxPrice.Price - (fees * maxPrice.Price))
		final := sellValue - 0.08 // Considered transfer fees to be $2
		if final > CAPITAL + 0.1 && minPrice.Market == "BINANCE" && maxPrice.Market == "KUCOIN" {
			// log.Printf("Arbitrage for %s: Buy on %s at %.4f, sell on %s at %.4f for %.2f USDT, get %.2f\n",
			// instId, minPrice.Market, minPrice.Price, maxPrice.Market, maxPrice.Price, CAPITAL, final)
			makeOrders(instId, "BINANCE", "KUCOIN", CAPITAL/minPrice.Price, CAPITAL*1.25/maxPrice.Price)
		}
		if final > CAPITAL + 0.1 && minPrice.Market == "KUCOIN" && maxPrice.Market == "BINANCE"  {
			// log.Printf("Arbitrage for %s: Buy on %s at %.4f, sell on %s at %.4f for %.2f USDT, get %.2f\n",
			// instId, minPrice.Market, minPrice.Price, maxPrice.Market, maxPrice.Price, CAPITAL, final)
			makeOrders(instId, "KUCOIN", "BINANCE", CAPITAL/minPrice.Price, CAPITAL*1.25/maxPrice.Price)
		}
	}
}

func makeOrders(instId string, buyMarket string, sellMarket string, buyAmount, sellAmount float64){
	base := strings.Split(instId, "-")[0]
	switch buyMarket {
		case "BINANCE":
			go func(){
				order.Binance("SPOT", math.Floor(buyAmount), instId)
				utils.PostBinanceBuy(base, math.Floor(buyAmount))
			}()

		case "KUCOIN":
			go func(){
				order.Kucoin("SPOT", instId, math.Floor(buyAmount))
				utils.PostKucoinBuy(base, math.Floor(buyAmount))
			}()
	}
	switch sellMarket {
		case "BINANCE":
			res , err := transfer.BinanceSpot2Margin("USDT", CAPITAL)
			if err != nil {
				log.Println("BiS2M error", err)
				return
			}
			log.Println("BiS2M success", res)
			time.Sleep(10*time.Millisecond)
			go order.Binance("MARGIN", sellAmount, instId)
		case "KUCOIN":
			res, err := transfer.KucoinSpot2Margin("USDT", CAPITAL)
			if err != nil {
				log.Println("KuS2M error", err)
				return
			}
			log.Println("KuS2M success", res)
			time.Sleep(10*time.Millisecond)
			go order.Kucoin("MARGIN", instId, sellAmount)
	}
}